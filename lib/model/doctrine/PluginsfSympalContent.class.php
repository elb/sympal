<?php

/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
abstract class PluginsfSympalContent extends BasesfSympalContent
{
  protected
    $_contentRouteObject;

  /**
   * Returns the slug with underscores instead of dashes
   *
   * Used when creating routes for content records with a custom_path
   *
   * @return string
   */
  public function getUnderscoredSlug()
  {
    return str_replace('-', '_', $this['slug']);
  }

  /**
   * @return string
   */
  public function getContentTypeClassName()
  {
    return $this->getType()->getTypeObject()->get('model');
  }

  /**
   * @return string
   */
  public function __toString()
  {
    return $this->Record->__toString();
  }

  /**
   * Returns the content type record related to this Content record, which
   * could be one of many classes (depending on the content type).
   *
   * If the class name of the content type related to this content were
   * "Product", then this method would be equivalent to the following:
   *
   * $content->Product
   *
   * @return Doctrine_Record|bool
   */
  public function getRecord()
  {
    if ($this['Type']['key'])
    {
      $model = $this['Type']->getTypeObject()->getModel();

      Doctrine_Core::initializeModels(array($model));

      return $this[$model];
    }
    else
    {
      return false;
    }
  }

  /**
   * Returns whether or not the field name exists on this record, the
   * content type record, or either Translation records.
   *
   * @param  string $name The field name
   * @return bool
   */
  public function hasField($name)
  {
    // check this model
    if ($this->_table->hasField($name))
    {
      return true;
    }

    // check sfSympalContentTranslation
    $className = get_class($this);
    if (Doctrine_Core::isValidModelClass($className.'Translation'))
    {
      if (Doctrine_Core::getTable($className.'Translation')->hasField($name))
      {
        return true;
      }
    }

    // check the content type record
    $className = $this->getType()->getTypeObject()->get('model');
    if (Doctrine_Core::getTable($className)->hasField($name))
    {
      return true;
    }

    // check the Translation class of the content type record
    if (Doctrine_Core::isValidModelClass($className.'Translation'))
    {
      if (Doctrine_Core::getTable($className.'Translation')->hasField($name))
      {
        return true;
      }
    }

    return false;
  }

  /**
   * Publishes this content with a published date of right now.
   *
   * @return void
   */
  public function publish()
  {
    $this->date_published = date('Y-m-d H:i:s');
    $this->save();
    $this->refresh();
  }

  /**
   * Upublishes this content
   *
   * @return void
   */
  public function unpublish()
  {
    $this->date_published = null;
    $this->save();
  }

  /**
   * Returns the content that will be output for xml, yml, and json formats
   *
   * This looks for a getXmlFormatData() named function on the content
   * type record, then on the sfSympalContent record. If neither is found,
   * getDefaultFormatData() is returned. In all cases, the method should
   * return an array.
   *
   * @param  string $format The format (e.g. xml, json, yml)
   * @return string
   */
  public function getFormatData($format)
  {
    $method = 'get'.ucfirst($format).'FormatData';

    if (method_exists($this->getContentTypeClassName(), $method))
    {
      $data = $this->getRecord()->$method();
    }
    else if (method_exists($this, $method))
    {
      $data = $this->$method();
    }
    else
    {
      $data = $this->getDefaultFormatData();
    }

    return Doctrine_Parser::dump($this->$method(), $format);
  }

  /**
   * Returns the default data to output for non-html formats that aren't
   * otherwise handled by getFormatData().
   *
   * @return array
   */
  public function getDefaultFormatData()
  {
    $data = $this->toArray(true);
    unset(
      $data['CreatedBy'],
      $data['Site']
    );

    return $data;
  }

  /**
   * Returns whether or not this content is published
   *
   * @return bool
   */
  public function getIsPublished()
  {
    return ($this->getDatePublished() && strtotime($this->getDatePublished()) <= time()) ? true : false;
  }

  /**
   * Returns whether or not this content is set with a published date in
   * the future.
   *
   * If this content is already published (date_published in the past), this
   * will return false.
   *
   * @return bool
   */
  public function getIsPublishedInTheFuture()
  {
    return ($this->getDatePublished() && strtotime($this->getDatePublished()) > time()) ? true : false;
  }

  /**
   * Getter for the month published
   *
   * @param string $format
   * @return string
   */
  public function getMonthPublished($format = 'm')
  {
    return date('m', strtotime($this->getDatePublished()));
  }

  /**
   * Getter for the day published
   *
   * @return string
   */
  public function getDayPublished()
  {
    return date('d', strtotime($this->getDatePublished()));
  }

  /**
   * Getter for the year published
   *
   * @return string
   */
  public function getYearPublished()
  {
    return date('Y', strtotime($this->getDatePublished()));
  }

  /**
   * Returns the name of the author of this record, if CreatedBy is set
   *
   * @return string
   */
  public function getAuthorName()
  {
    return $this->getCreatedById() ? $this->getCreatedBy()->getName() : null;
  }

  /**
   * Returns the author of the
   *
   * @return string
   */
  public function getAuthorEmail()
  {
    return $this->getCreatedById() ? $this->getCreatedBy()->getEmailAddress() : null;
  }

  /**
   * Returns the route object related to this content record
   *
   * @return sfSympalContentRouteObject
   */
  public function getContentRouteObject()
  {
    if (!$this->_contentRouteObject)
    {
      $this->_contentRouteObject = new sfSympalContentRouteObject($this);
    }

    return $this->_contentRouteObject;
  }

  /**
   * Returns the url to this content
   *
   * @param array $options The array of url options
   * @return string
   */
  public function getUrl($options = array())
  {
    return sfContext::getInstance()->getController()->genUrl($this->getRoute(), $options);
  }

  /**
   * This gets the correct template to render with
   *
   * The process is this:
   *   1) Look first on the content record itself for a template "name"
   *   2) Look next on the type record for a template "name"
   *
   * We then retrieve the actual template (module/template) by looking
   * under the "content_templates" key of the current content template's
   * configuration for the template "name".
   *
   * If all else fails, the "default_view" template name of the current
   * content type config will be used
   */
  public function getTemplateToRenderWith()
  {
    if (!$templateName = $this->getTemplate())
    {
      $templateName = $this->getType()->getTemplate();
    }

    $templates = sfSympalConfig::getContentTemplates($this['Type']['name']);

    if (!isset($templates[$templateName]))
    {
      $templateName = 'default_view';
      if (!isset($templates[$templateName]))
      {
        throw new sfException(sprintf('No "default_view" template specified for "%s" content type', $this->getType()->getName()));
      }
    }

    if (!is_array($templates[$templateName]) || !isset($templates[$templateName]['template']))
    {
      throw new sfException(sprintf('Key "template" must be set under content_template "%s" in app.yml', $templateName));
    }

    return $templates[$templateName]['template'];
  }

  /**
   * @param Doctrine_Connection $conn
   */
  public function save(Doctrine_Connection $conn = null)
  {
    if (!$this->relatedExists('Site'))
    {
      $site = Doctrine_Core::getTable('sfSympalSite')->fetchCurrent(true);
      $this->Site = $site;
    }

    $result = parent::save($conn);

    return $result;
  }

  /**
   * @param Doctrine_Connection $conn
   * @return bool
   */
  public function delete(Doctrine_Connection $conn = null)
  {
    // delete content from accociated content type table
    $this->getRecord()->delete();

    return parent::delete($conn);
  }

  /**
   * Returns the page title to be used for this content. This will retrieve
   * the page title from the Site relation if not set on this record.
   *
   * @return string
   */
  public function getPageTitleForRendering()
  {
    if ($pageTitle = $this->getPageTitle())
    {
      return $pageTitle;
    }
    else if ($pageTitle = $this->getSite()->getPageTitle())
    {
      return $pageTitle;
    }
    else if (sfSympalConfig::get('auto_seo', 'title'))
    {
      if (method_exists($this->getContentTypeClassName(), 'getAutoSeoTitle'))
      {
        return $this->Record->getAutoSeoTitle();
      }

      return $this->getAutoSeoTitle();
    }

    return null;
  }

  /**
   * Generates a page title for this content record
   *
   * @return string
   */
  public function getAutoSeoTitle()
  {
    $format = sfSympalConfig::get('auto_seo', 'title_format');
    $find = array(
      '%site_title%',
      '%content_title%',
      '%content_id%',
    );

    $replace = array(
      $this->getSite()->getTitle(),
      (string) $this,
      $this->getId(),
    );
    $title = str_replace($find, $replace, $format);

    return $title;
  }

  /**
   * Returns the meta keyowrds to be used for this content record
   *
   * @return string
   */
  public function getMetaKeywordsForRendering()
  {
    if ($metaKeywords = $this->getMetaKeywords())
    {
      return $metaKeywords;
    }
    else if ($metaKeywords = $this->getSite()->getMetaKeywords())
    {
      return $metaKeywords;
    }
  }

  /**
   * Returns the meta description to be used for this content record
   *
   * @return string
   */
  public function getMetaDescriptionForRendering()
  {
    if ($metaDescription = $this->getMetaDescription())
    {
      return $metaDescription;
    }
    else if ($metaDescription = $this->getSite()->getMetaDescription())
    {
      return $metaDescription;
    }
  }

  /**
   * @TODO refactor this for the new system
   *
   * Used by sfSympalContentSlot to render the created_at_id slot value
   *
   * @see sfSympalContentSlot::getValueForRendering()
   * @return string
   */
  public function getCreatedByIdSlotValue(sfSympalContentSlot $slot)
  {
    return $this->created_by_id ? $this->CreatedBy->username : 'nobody';
  }

  /**
   * @TODO refactor this for the new system
   *
   * Used by sfSympalContentSlot to render the date_published slot value
   *
   * @see sfSympalContentSlot::getValueForRendering()
   * @return string
   */
  public function getDatePublishedSlotValue(sfSympalContentSlot $slot)
  {
    if ($this->date_published)
    {
      sfApplicationConfiguration::loadHelpers('Date');

      return format_datetime($this->date_published, sfSympalConfig::get('date_published_format'));
    }
    else
    {
      return 'unpublished';
    }
  }

  /**
   * For a data that exists both in sfSympalContent and sfSympalContentType
   * (either in the model or in the config), this will return the value from
   * the sfSympalContent object if it exists and default to sfSympalContentType
   * object otherwise.
   *
   * This gives us a type of cascading configuration.
   *
   * @param  string $name The name of the field to look for
   * @return void
   */
  public function getContentOption($name, $default = null)
  {
    if ($this->contains($name) && $value = $this->get($name))
    {
      return $value;
    }

    return $this->Type->getTypeObject()->get($name, $default);
  }
}
